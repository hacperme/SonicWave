<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sonic Wave - å…è´¹åœ¨çº¿éŸ³é¢‘è½¬æ¢å‹ç¼©å·¥å…· | MP3/WAV/M4A/FLACæ‰¹é‡è½¬æ¢</title>
    <meta name="description" content="Sonic Waveæ˜¯ä¸€æ¬¾å…è´¹çš„åœ¨çº¿éŸ³é¢‘è½¬æ¢ä¸å‹ç¼©å·¥å…·ï¼Œæ”¯æŒMP3ã€WAVã€M4Aã€AACã€OGGã€FLACç­‰æ ¼å¼äº’è½¬å’Œå‹ç¼©ï¼Œå…·å¤‡æ‰¹é‡æ–‡ä»¶å¤„ç†åŠŸèƒ½ï¼Œæ— éœ€ä¸‹è½½å®‰è£…ï¼Œç›´æ¥åœ¨æµè§ˆå™¨ä¸­å®Œæˆã€‚">
    <meta name="keywords" content="éŸ³é¢‘è½¬æ¢,éŸ³é¢‘å‹ç¼©,MP3å‹ç¼©,æ‰¹é‡éŸ³é¢‘è½¬æ¢,æ‰¹é‡éŸ³é¢‘å¤„ç†,WAVè½¬æ¢,M4Aè½¬æ¢,FLACè½¬æ¢,åœ¨çº¿éŸ³é¢‘å·¥å…·,å…è´¹éŸ³é¢‘å‹ç¼©">
    <meta name="author" content="Sonic Wave">
    <meta name="robots" content="index, follow">
    <meta name="theme-color" content="#4285f4">
    <link rel="canonical" href="/">
    <link rel="stylesheet" href="./assets/styles.css">
    
    <!-- ç»“æ„åŒ–æ•°æ® (Schema.org) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": ["SoftwareApplication", "WebApplication"],
      "name": "Sonic Wave - éŸ³é¢‘è½¬æ¢å‹ç¼©å·¥å…·",
      "description": "å…è´¹åœ¨çº¿éŸ³é¢‘è½¬æ¢å‹ç¼©å·¥å…·ï¼Œæ”¯æŒMP3ã€WAVã€M4Aã€AACã€OGGã€FLACç­‰æ ¼å¼äº’è½¬ã€éŸ³é¢‘å‹ç¼©å’Œæ‰¹é‡æ–‡ä»¶å¤„ç†",
      "applicationCategory": "UtilitiesApplication",
      "operatingSystem": "Web",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "CNY"
      },
      "featureList": [
        "æ”¯æŒMP3ã€WAVã€M4Aã€AACã€OGGã€FLACç­‰å¤šç§éŸ³é¢‘æ ¼å¼äº’è½¬",
        "éŸ³é¢‘å‹ç¼©åŠŸèƒ½ï¼Œè°ƒæ•´æ¯”ç‰¹ç‡å’Œé‡‡æ ·ç‡å‡å°æ–‡ä»¶ä½“ç§¯",
        "æ‰¹é‡æ–‡ä»¶å¤„ç†ï¼Œä¸€æ¬¡æ€§å¤„ç†å¤šä¸ªéŸ³é¢‘æ–‡ä»¶",
        "æœ¬åœ°å¤„ç†ä¿æŠ¤éšç§å®‰å…¨",
        "åœ¨çº¿æ“ä½œï¼Œæ— éœ€ä¸‹è½½å®‰è£…",
        "å…è´¹ä½¿ç”¨",
        "ç®€å•æ˜“ç”¨çš„ç•Œé¢"
      ],
      "screenshot": "/",
      "softwareVersion": "1.0",
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "100"
      }
    }
    </script>
</head>
<body>

<div class="container">
    <header>
        <h1>ğŸµ Sonic Wave - å…è´¹åœ¨çº¿éŸ³é¢‘è½¬æ¢å‹ç¼©å·¥å…·</h1>
    </header>
    <main>
    <!-- æ‹–æ‹½ä¸Šä¼ åŒºåŸŸ -->
    <div class="drop-zone" id="drop-zone">
        <div class="drop-zone-text">ğŸ“ æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©</div>
        <div class="drop-zone-hint">æ”¯æŒ MP3/WAV/M4A/AAC/OGG/FLACï¼Œå¯å¤šé€‰</div>
        <div class="drop-zone-hint hint">ğŸ’¡ å•æ–‡ä»¶â‰¤100MBï¼Œæ€»å¤§å°â‰¤500MB</div>
    </div>
    
    <div class="form-group" style="display: none;">
        <input type="file" id="uploader" accept="audio/*" multiple>
    </div>

    <div id="file-list" class="hidden" style="margin-top: 15px; padding: 15px; background: #f9f9f9; border-radius: 6px;">
        <h4 style="margin-bottom: 10px;">å·²é€‰æ‹© <span id="file-count">0</span> ä¸ªæ–‡ä»¶</h4>
        <div id="file-items" style="max-height: 300px; overflow-y: auto;"></div>
    </div>

    <div id="original-info" class="original-info hidden">
        <h4>æ–‡ä»¶ä¿¡æ¯ï¼š</h4>
        <table>
            <tr><td>æ–‡ä»¶å:</td><td id="info-name">N/A</td></tr>
            <tr><td>æ—¶é•¿:</td><td id="info-duration">N/A</td></tr>
            <tr><td>é‡‡æ ·ç‡:</td><td id="info-samplerate">N/A</td></tr>
            <tr><td>å£°é“:</td><td id="info-channels">N/A</td></tr>
            <tr><td>åŸå§‹æ¯”ç‰¹ç‡:</td><td id="info-bitrate">N/A</td></tr>
        </table>
    </div>

    <div style="margin-top: 20px;">
        <label>2. è¾“å‡ºæ ¼å¼ä¸å‚æ•°</label>
        <div class="settings-grid">
            
            <select id="output-format">
                <option value="mp3">MP3</option>
                <option value="wav">WAV (æ— æŸ)</option>
                <option value="aac">AAC/M4A</option>
                <option value="ogg">OGG Vorbis</option>
                <option value="flac">FLAC (æ— æŸ)</option>
            </select>
            
            <select id="output-channels">
                <option value="">å£°é“ (ä¿æŒä¸å˜)</option>
                <option value="1">å•å£°é“ (Mono)</option>
                <option value="2">ç«‹ä½“å£° (Stereo)</option>
            </select>
            
            <select id="output-samplerate">
                <option value="">é‡‡æ ·ç‡ (ä¿æŒä¸å˜)</option>
                <option value="48000">48 kHz (é«˜æ¸…æ ‡å‡†)</option>
                <option value="44100" selected>44.1 kHz (CD æ ‡å‡†)</option>
                <option value="32000">32 kHz</option>
                <option value="24000">24 kHz</option>
                <option value="22050">22.05 kHz</option>
                <option value="16000">16 kHz (è¯­éŸ³)</option>
                <option value="11025">11.025 kHz</option>
                <option value="8000">8 kHz (ç”µè¯)</option>
            </select>

            <select id="output-bitrate">
                <option value="">æ¯”ç‰¹ç‡ (ä¿æŒä¸å˜)</option>
                <option value="320k">320 kbps (æœ€é«˜è´¨é‡)</option>
                <option value="256k">256 kbps (é«˜å“è´¨)</option>
                <option value="192k">192 kbps (é«˜)</option>
                <option value="160k">160 kbps</option>
                <option value="128k" selected>128 kbps (æ ‡å‡†)</option>
                <option value="112k">112 kbps</option>
                <option value="96k">96 kbps (ä¸­)</option>
                <option value="80k">80 kbps</option>
                <option value="64k">64 kbps (ä½)</option>
                <option value="56k">56 kbps</option>
                <option value="48k">48 kbps</option>
                <option value="32k">32 kbps (è¯­éŸ³)</option>
                <option value="24k">24 kbps</option>
                <option value="16k">16 kbps (æœ€ä½)</option>
            </select>
        </div>
        <div style="margin-top: 10px; font-size: 13px; color: #666;">
            <span id="format-hint">ğŸ’¡ æç¤º: MP3 æ ¼å¼æ”¯æŒæ¯”ç‰¹ç‡è®¾ç½®ï¼ŒWAV/FLAC ä¸ºæ— æŸæ ¼å¼</span>
        </div>
    </div>
    
    <!-- è¿›åº¦æ¡ -->
    <div class="progress-container" id="progress-container">
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
        </div>
        <div class="progress-text" id="progress-text">0 / 0 å·²å®Œæˆ</div>
    </div>

    <button id="compress-btn" disabled style="margin-top: 20px;">åŠ è½½ FFmpeg æ ¸å¿ƒä¸­...</button>

    <div id="batch-results" class="batch-results hidden">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">è½¬æ¢ç»“æœ</h4>
            <button id="download-all-btn" class="success-btn" style="display: none; padding: 8px 16px; font-size: 14px;">ğŸ“¦ æ‰“åŒ…ä¸‹è½½å…¨éƒ¨</button>
        </div>
        <div id="results-container"></div>
    </div>

    <section id="download-area" class="hidden">
        <p>å‹ç¼©å®Œæˆï¼</p>
        <a id="download-link" class="success-btn" href="#" download>ä¸‹è½½è½¬æ¢åçš„éŸ³é¢‘</a>
        <p id="size-info" style="font-size: 0.9em; color: #666; margin-top: 10px;"></p>
    </section>

    <section id="log-section">
        <div id="log">æ­£åœ¨åˆå§‹åŒ–...</div>
    </section>
    </main>
</div>

<script src="./assets/ffmpeg.js"></script>
<script src="./assets/util.js"></script>
<script src="./assets/jszip.min.js"></script>

<script>
    // å¯¼å…¥å…¨å±€å‘½åç©ºé—´ä¸­çš„ç±»ï¼ˆFFmpegWASM å’Œ FFmpegUtil æ˜¯ UMD æ–‡ä»¶å®šä¹‰çš„å…¨å±€å¯¹è±¡ï¼‰
    const { FFmpeg } = FFmpegWASM;
    const { fetchFile } = FFmpegUtil;
    
    let ffmpeg = null;
    const logEl = document.getElementById('log');
    const btn = document.getElementById('compress-btn');
    const uploader = document.getElementById('uploader');
    const downloadArea = document.getElementById('download-area');
    const downloadLink = document.getElementById('download-link');
    const infoArea = document.getElementById('original-info');
    const fileListArea = document.getElementById('file-list');
    const fileItems = document.getElementById('file-items');
    const fileCount = document.getElementById('file-count');
    const batchResults = document.getElementById('batch-results');
    const resultsContainer = document.getElementById('results-container');
    const downloadAllBtn = document.getElementById('download-all-btn');
    const formatHint = document.getElementById('format-hint');
    const dropZone = document.getElementById('drop-zone');
    const progressContainer = document.getElementById('progress-container');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');

    // æ–°å¢çš„è¾“å…¥å…ƒç´ 
    const outputFormat = document.getElementById('output-format');
    const outputBitrate = document.getElementById('output-bitrate');
    const outputSamplerate = document.getElementById('output-samplerate');
    const outputChannels = document.getElementById('output-channels');
    
    // æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½
    dropZone.addEventListener('click', () => uploader.click());
    
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('drag-over');
    });
    
    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('drag-over');
    });
    
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('drag-over');
        uploader.files = e.dataTransfer.files;
        displayFileList();
    });

    let selectedFiles = [];
    
    // æ–‡ä»¶å¤§å°é™åˆ¶ï¼ˆå­—èŠ‚ï¼‰
    const MAX_SINGLE_FILE_SIZE = 100 * 1024 * 1024; // 100MB
    const MAX_TOTAL_SIZE = 500 * 1024 * 1024; // 500MB
    
    // é”™è¯¯æ¶ˆæ¯æ˜ å°„
    const ERROR_MESSAGES = {
        'out of memory': 'âŒ æ–‡ä»¶è¿‡å¤§å¯¼è‡´å†…å­˜ä¸è¶³ï¼Œå»ºè®®ï¼š\n  â€¢ ä½¿ç”¨è¾ƒå°çš„æ–‡ä»¶\n  â€¢ é™ä½è¾“å‡ºè´¨é‡å‚æ•°\n  â€¢ åˆ†æ®µå¤„ç†',
        'invalid data': 'âŒ æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒæˆ–æ–‡ä»¶å·²æŸåï¼Œè¯·æ£€æŸ¥æ–‡ä»¶å®Œæ•´æ€§',
        'timeout': 'âŒ å¤„ç†è¶…æ—¶ï¼Œå»ºè®®ï¼š\n  â€¢ ç¼©çŸ­éŸ³é¢‘é•¿åº¦\n  â€¢ åˆ†æ®µå¤„ç†\n  â€¢ é™ä½è¾“å‡ºè´¨é‡',
        'no such file': 'âŒ æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡æ–°é€‰æ‹©æ–‡ä»¶',
        'codec': 'âŒ ç¼–ç å™¨é”™è¯¯ï¼Œè¯·å°è¯•å…¶ä»–è¾“å‡ºæ ¼å¼'
    };
    
    const getFriendlyError = (error) => {
        const message = error.message || error.toString();
        for (const [key, msg] of Object.entries(ERROR_MESSAGES)) {
            if (message.toLowerCase().includes(key)) {
                return msg;
            }
        }
        return `âŒ å¤„ç†å¤±è´¥: ${message}`;
    };

    // æ ¼å¼é…ç½®
    const formatConfig = {
        mp3: { ext: 'mp3', codec: 'libmp3lame', supportsBitrate: true, hint: 'ğŸ’¡ MP3 - æœ‰æŸå‹ç¼©ï¼Œæ”¯æŒæ¯”ç‰¹ç‡è®¾ç½®ï¼Œå…¼å®¹æ€§æœ€å¥½' },
        wav: { ext: 'wav', codec: 'pcm_s16le', supportsBitrate: false, hint: 'ğŸ’¡ WAV - æ— æŸæ ¼å¼ï¼Œæ–‡ä»¶è¾ƒå¤§ï¼ŒéŸ³è´¨æœ€ä½³' },
        aac: { ext: 'm4a', codec: 'aac', supportsBitrate: true, hint: 'ğŸ’¡ AAC/M4A - æœ‰æŸå‹ç¼©ï¼ŒéŸ³è´¨ä¼˜äºåŒæ¯”ç‰¹ç‡MP3ï¼Œç°ä»£è®¾å¤‡æ”¯æŒå¥½' },
        ogg: { ext: 'ogg', codec: 'libvorbis', supportsBitrate: true, hint: 'ğŸ’¡ OGG Vorbis - å¼€æºæœ‰æŸæ ¼å¼ï¼ŒéŸ³è´¨å¥½ï¼Œæ–‡ä»¶å°' },
        flac: { ext: 'flac', codec: 'flac', supportsBitrate: false, hint: 'ğŸ’¡ FLAC - æ— æŸå‹ç¼©ï¼Œæ¯”WAVå°30-50%ï¼Œä¿çœŸéŸ³è´¨' }
    };

    // æ ¼å¼åˆ‡æ¢æ—¶æ›´æ–°æç¤ºå’Œæ¯”ç‰¹ç‡å¯ç”¨æ€§
    outputFormat.addEventListener('change', () => {
        const format = formatConfig[outputFormat.value];
        formatHint.textContent = format.hint;
        outputBitrate.disabled = !format.supportsBitrate;
        if (!format.supportsBitrate) {
            outputBitrate.value = '';
        }
    });


    const log = (message) => {
        logEl.innerHTML += `\n${message}`;
        logEl.scrollTop = logEl.scrollHeight;
    };

    // ------------------------------------
    // 1. åˆå§‹åŒ– FFmpeg (ä½¿ç”¨ç»å¯¹è·¯å¾„åŠ è½½)
    // ------------------------------------
    const loadFFmpeg = async () => {
        ffmpeg = new FFmpeg();
        
        ffmpeg.on('log', ({ message }) => log(message));
        ffmpeg.on('progress', ({ progress }) => log(`å¤„ç†è¿›åº¦: ${(progress * 100).toFixed(1)}%`));

        try {
            // ä½¿ç”¨ç»å¯¹è·¯å¾„åŠ è½½æ ¸å¿ƒæ–‡ä»¶ (ä¿®å¤äº† Worker è·¯å¾„é—®é¢˜)
            await ffmpeg.load({
                coreURL: '/assets/ffmpeg-core.js',
                wasmURL: '/assets/ffmpeg-core.wasm',
            });
            
            log('FFmpeg æ ¸å¿ƒåŠ è½½æˆåŠŸï¼è¯·é€‰æ‹©æ–‡ä»¶ã€‚');
            btn.innerText = 'å¼€å§‹å‹ç¼©';
            btn.disabled = false;
        } catch (e) {
            log(`åŠ è½½å¤±è´¥: ${e.message || e}`);
            log("è¯·æ£€æŸ¥æœåŠ¡å™¨é…ç½®æˆ– assets æ–‡ä»¶å¤¹ã€‚");
            console.error(e);
        }
    };

    // ------------------------------------
    // æ–‡ä»¶é€‰æ‹©å¤„ç†
    // ------------------------------------
    const displayFileList = async () => {
        selectedFiles = Array.from(uploader.files);
        
        if (selectedFiles.length === 0) {
            fileListArea.classList.add('hidden');
            infoArea.classList.add('hidden');
            batchResults.classList.add('hidden');
            return;
        }
        
        // éªŒè¯æ–‡ä»¶å¤§å°
        let totalSize = 0;
        let hasOversizedFile = false;
        
        for (const file of selectedFiles) {
            totalSize += file.size;
            if (file.size > MAX_SINGLE_FILE_SIZE) {
                hasOversizedFile = true;
                alert(`æ–‡ä»¶ "${file.name}" è¶…è¿‡ 100MB é™åˆ¶ (${(file.size / 1024 / 1024).toFixed(2)} MB)\nå»ºè®®ä½¿ç”¨è¾ƒå°çš„æ–‡ä»¶ã€‚`);
            }
        }
        
        if (hasOversizedFile) {
            uploader.value = '';
            return;
        }
        
        if (totalSize > MAX_TOTAL_SIZE) {
            alert(`æ€»æ–‡ä»¶å¤§å° ${(totalSize / 1024 / 1024).toFixed(2)} MB è¶…è¿‡ 500MB é™åˆ¶\nè¯·å‡å°‘æ–‡ä»¶æ•°é‡æˆ–é€‰æ‹©è¾ƒå°çš„æ–‡ä»¶ã€‚`);
            uploader.value = '';
            return;
        }
        
        // æ¸…é™¤ä¹‹å‰çš„è½¬æ¢ç»“æœ
        resultsContainer.innerHTML = '';
        batchResults.classList.add('hidden');
        downloadAllBtn.style.display = 'none';
        
        fileCount.textContent = selectedFiles.length;
        fileListArea.classList.remove('hidden');
        infoArea.classList.add('hidden');
        
        // åˆ›å»ºæ–‡ä»¶åˆ—è¡¨é¡¹
        fileItems.innerHTML = selectedFiles.map((file, index) => {
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            return `
                <div class="file-item" data-index="${index}">
                    <div class="header">
                        <span class="name">${file.name}</span>
                        <span class="size">${sizeMB} MB</span>
                        <span class="status status-pending">è§£æä¸­...</span>
                    </div>
                    <div class="metadata" id="metadata-${index}">
                        <span>â± <strong id="duration-${index}">-</strong></span>
                        <span>ğŸµ <strong id="samplerate-${index}">-</strong></span>
                        <span>ğŸ“» <strong id="channels-${index}">-</strong></span>
                        <span>ğŸ’¿ <strong id="bitrate-${index}">-</strong></span>
                    </div>
                </div>
            `;
        }).join('');
        
        btn.innerText = `æ‰¹é‡å‹ç¼© (${selectedFiles.length} ä¸ªæ–‡ä»¶)`;
        
        // å¼‚æ­¥è§£ææ‰€æœ‰æ–‡ä»¶çš„å…ƒæ•°æ®
        parseAllFilesMetadata();
    };
    
    const getFileExtension = (filename) => {
        return filename.split('.').pop().toLowerCase();
    };
    
    const parseAllFilesMetadata = async () => {
        for (let i = 0; i < selectedFiles.length; i++) {
            const file = selectedFiles[i];
            const inputName = `temp_${i}.` + file.name.split('.').pop();
            
            try {
                await ffmpeg.writeFile(inputName, await fetchFile(file));
                
                // æ‰§è¡Œ -i è·å–å…ƒæ•°æ®
                try {
                    await ffmpeg.exec(['-i', inputName]);
                } catch (e) {
                    // æ­£å¸¸ä¼šå¤±è´¥
                }
                
                // ä»æ—¥å¿—è§£æ
                const logs = logEl.innerText;
                const metadata = parseMetadata(logs);
                
                // æ›´æ–°å¯¹åº”æ–‡ä»¶çš„æ˜¾ç¤º
                document.getElementById(`duration-${i}`).textContent = metadata.duration;
                document.getElementById(`samplerate-${i}`).textContent = metadata.sampleRate;
                document.getElementById(`channels-${i}`).textContent = metadata.channels;
                document.getElementById(`bitrate-${i}`).textContent = metadata.bitrate;
                
                // æ˜¾ç¤ºå…ƒæ•°æ®åŒºåŸŸ
                document.getElementById(`metadata-${i}`).classList.add('loaded');
                
                // æ›´æ–°çŠ¶æ€
                const statusEl = fileItems.querySelector(`[data-index="${i}"] .status`);
                statusEl.className = 'status status-pending';
                statusEl.textContent = 'ç­‰å¾…å¤„ç†';
                
                // æ¸…ç©ºæ—¥å¿—
                logEl.innerHTML = `å·²è§£æ ${i + 1}/${selectedFiles.length} ä¸ªæ–‡ä»¶...`;
                
                // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                await ffmpeg.deleteFile(inputName);
                
            } catch (error) {
                console.error(`è§£æ ${file.name} å¤±è´¥:`, error);
                const statusEl = fileItems.querySelector(`[data-index="${i}"] .status`);
                statusEl.className = 'status status-error';
                statusEl.textContent = 'è§£æå¤±è´¥';
            }
        }
        
        logEl.innerHTML = 'æ‰€æœ‰æ–‡ä»¶ä¿¡æ¯è§£æå®Œæˆï¼Œå¯ä»¥å¼€å§‹å‹ç¼©ã€‚';
    };
    
    const updateFileStatus = (index, status, message = '') => {
        const item = fileItems.querySelector(`[data-index="${index}"]`);
        if (!item) return;
        
        const statusEl = item.querySelector('.status');
        statusEl.className = 'status';
        
        switch(status) {
            case 'processing':
                statusEl.classList.add('status-processing');
                statusEl.textContent = 'å¤„ç†ä¸­...';
                break;
            case 'done':
                statusEl.classList.add('status-done');
                statusEl.textContent = 'âœ“ å®Œæˆ';
                break;
            case 'error':
                statusEl.classList.add('status-error');
                statusEl.textContent = 'âœ— å¤±è´¥';
                break;
        }
    };

    // ------------------------------------
    // 2. è§£æåŸå§‹æ–‡ä»¶ä¿¡æ¯ (ä¿®å¤ç‰ˆ)
    // ------------------------------------
    const parseMetadata = (logOutput) => {
        // stderr æ˜¯ Uint8Arrayï¼Œéœ€è¦è½¬æ¢ä¸ºå­—ç¬¦ä¸²
        let logString = '';
        if (logOutput instanceof Uint8Array) {
            logString = new TextDecoder().decode(logOutput);
        } else if (typeof logOutput === 'string') {
            logString = logOutput;
        }
        
        if (!logString) {
            return { duration: 'N/A', sampleRate: 'N/A', channels: 'N/A', bitrate: 'N/A' };
        }
        
        const metadata = {};
        
        // Duration: åŒ¹é… "Duration: 00:28:33.79"
        const durationMatch = logString.match(/Duration:\s*(\d{2}:\d{2}:\d{2}\.\d+)/);
        metadata.duration = durationMatch ? durationMatch[1] : 'N/A';

        // Sample Rate & Channels: åŒ¹é… "44100 Hz, mono" æˆ– "48000 Hz, stereo"
        const streamMatch = logString.match(/(\d+)\s*Hz,\s*(mono|stereo|5\.1|quad)/i);
        if (streamMatch) {
            const sampleRateHz = parseInt(streamMatch[1]);
            metadata.sampleRate = `${(sampleRateHz / 1000).toFixed(1)} kHz`;
            metadata.channels = streamMatch[2].charAt(0).toUpperCase() + streamMatch[2].slice(1);
        } else {
            metadata.sampleRate = 'N/A';
            metadata.channels = 'N/A';
        }

        // Bitrate: åŒ¹é… "bitrate: 64 kb/s"
        const bitrateMatch = logString.match(/bitrate:\s*(\d+)\s*kb\/s/i);
        metadata.bitrate = bitrateMatch ? `${bitrateMatch[1]} kbps` : 'N/A';
        
        return metadata;
    };

    // ------------------------------------
    // 3. æ‰¹é‡å‹ç¼©é€»è¾‘ 
    // ------------------------------------
    const compressBatch = async () => {
        if (selectedFiles.length === 0) {
            return alert('è¯·å…ˆé€‰æ‹©æ–‡ä»¶');
        }

        btn.disabled = true;
        btn.innerText = 'æ‰¹é‡å‹ç¼©ä¸­...';
        downloadArea.classList.add('hidden');
        resultsContainer.innerHTML = '';
        batchResults.classList.remove('hidden');
        downloadAllBtn.style.display = 'none';
        progressContainer.style.display = 'block';
        
        logEl.innerHTML = '--- å¼€å§‹æ‰¹é‡å¤„ç† ---';

        const results = [];
        const format = formatConfig[outputFormat.value]; // æåˆ°å¤–å±‚
        
        for (let i = 0; i < selectedFiles.length; i++) {
            const file = selectedFiles[i];
            
            // æ›´æ–°è¿›åº¦
            const progress = ((i / selectedFiles.length) * 100).toFixed(0);
            progressFill.style.width = progress + '%';
            progressText.textContent = `${i} / ${selectedFiles.length} å·²å®Œæˆ`;
            
            updateFileStatus(i, 'processing');
            log(`\n[${i + 1}/${selectedFiles.length}] å¤„ç†: ${file.name}`);
            
            try {
                const result = await compressSingleFileWithRetry(file);
                results.push(result);
                updateFileStatus(i, 'done');
                
                // æ·»åŠ åˆ°ç»“æœåŒºåŸŸ
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';
                resultDiv.innerHTML = `
                    <div class="filename">${file.name} â†’ ${result.filename}</div>
                    <div class="info">
                        åŸå§‹: ${(file.size / 1024 / 1024).toFixed(2)} MB (${getFileExtension(file.name).toUpperCase()}) â†’ 
                        è½¬æ¢å: ${(result.blob.size / 1024 / 1024).toFixed(2)} MB (${format.ext.toUpperCase()})
                        ${file.size > result.blob.size ? 
                            `(å‡å° ${((1 - result.blob.size / file.size) * 100).toFixed(1)}%)` : 
                            `(å¢å¤§ ${((result.blob.size / file.size - 1) * 100).toFixed(1)}%)`}
                    </div>
                    <a href="${result.url}" download="${result.filename}">ğŸ“¥ ä¸‹è½½</a>
                `;
                resultsContainer.appendChild(resultDiv);
                
            } catch (error) {
                updateFileStatus(i, 'error');
                const friendlyError = getFriendlyError(error);
                log(`âœ— ${file.name} å¤±è´¥:\n${friendlyError}`);
                
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';
                resultDiv.style.borderLeftColor = '#dc3545';
                resultDiv.innerHTML = `
                    <div class="filename">${file.name}</div>
                    <div class="info" style="color: #dc3545; white-space: pre-line;">${friendlyError}</div>
                `;
                resultsContainer.appendChild(resultDiv);
            }
        }
        
        // å®Œæˆè¿›åº¦
        progressFill.style.width = '100%';
        progressText.textContent = `${selectedFiles.length} / ${selectedFiles.length} å·²å®Œæˆ`;
        
        log(`\n--- æ‰¹é‡å¤„ç†å®Œæˆ (æˆåŠŸ: ${results.length}/${selectedFiles.length}) ---`);
        btn.disabled = false;
        btn.innerText = `æ‰¹é‡å‹ç¼© (${selectedFiles.length} ä¸ªæ–‡ä»¶)`;
        
        // å¦‚æœæœ‰å¤šä¸ªæˆåŠŸçš„æ–‡ä»¶ï¼Œæ˜¾ç¤ºæ‰“åŒ…ä¸‹è½½æŒ‰é’®
        if (results.length > 1) {
            downloadAllBtn.style.display = 'inline-block';
            downloadAllBtn.onclick = () => downloadAsZip(results);
        }
    };

    // ------------------------------------
    // 4. æ‰“åŒ…ä¸‹è½½åŠŸèƒ½
    // ------------------------------------
    const downloadAsZip = async (results) => {
        log('\næ­£åœ¨æ‰“åŒ…æ–‡ä»¶...');
        downloadAllBtn.disabled = true;
        downloadAllBtn.textContent = 'ğŸ“¦ æ‰“åŒ…ä¸­...';
        
        try {
            const zip = new JSZip();
            
            for (const result of results) {
                // ä» blob ä¸­è¯»å–æ•°æ®å¹¶æ·»åŠ åˆ° zip
                const arrayBuffer = await result.blob.arrayBuffer();
                zip.file(result.filename, arrayBuffer);
            }
            
            // ç”Ÿæˆ zip æ–‡ä»¶
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `compressed_batch_${Date.now()}.zip`;
            a.click();
            
            URL.revokeObjectURL(url);
            log('æ‰“åŒ…å®Œæˆï¼');
            
        } catch (error) {
            log(`æ‰“åŒ…å¤±è´¥: ${error.message}`);
            alert('æ‰“åŒ…å¤±è´¥: ' + error.message);
        } finally {
            downloadAllBtn.disabled = false;
            downloadAllBtn.textContent = 'ğŸ“¦ æ‰“åŒ…ä¸‹è½½å…¨éƒ¨';
        }
    };
    
    // å¸¦é‡è¯•çš„å‹ç¼©å‡½æ•°
    const compressSingleFileWithRetry = async (file, maxRetries = 2) => {
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return await compressSingleFile(file);
            } catch (error) {
                if (attempt < maxRetries) {
                    log(`âš ï¸ ç¬¬ ${attempt + 1} æ¬¡å°è¯•å¤±è´¥ï¼Œé‡è¯•ä¸­...`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    throw error;
                }
            }
        }
    };

    const compressSingleFile = async (file) => {
        const inputExt = getFileExtension(file.name);
        const inputName = 'input.' + inputExt;
        const format = formatConfig[outputFormat.value];
        const outputName = 'output.' + format.ext;
        
        try {
            // å†™å…¥æ–‡ä»¶åˆ°å†…å­˜
            await ffmpeg.writeFile(inputName, await fetchFile(file));

            const command = ['-i', inputName];
            
            // åº”ç”¨å‚æ•°
            const ac = outputChannels.value;
            if (ac) command.push('-ac', ac);

            const ar = outputSamplerate.value;
            if (ar) command.push('-ar', ar);
            
            // éŸ³é¢‘ç¼–ç å™¨
            command.push('-acodec', format.codec);
            
            // æ¯”ç‰¹ç‡ï¼ˆä»…æœ‰æŸæ ¼å¼ï¼‰
            const ba = outputBitrate.value;
            if (ba && format.supportsBitrate) {
                command.push('-b:a', ba);
            }
            
            // æ— æŸæ ¼å¼ç‰¹æ®Šå¤„ç†
            if (outputFormat.value === 'flac') {
                command.push('-compression_level', '5'); // FLAC å‹ç¼©çº§åˆ« 0-12
            } else if (outputFormat.value === 'aac') {
                command.push('-strict', 'experimental'); // AAC ç¼–ç å™¨å…¼å®¹æ€§
            }

            command.push(outputName);
            
            // æ‰§è¡Œ FFmpeg å‘½ä»¤
            await ffmpeg.exec(command);
            
            // è¯»å–è¾“å‡ºæ–‡ä»¶
            const data = await ffmpeg.readFile(outputName);
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const mimeType = {
                mp3: 'audio/mpeg',
                wav: 'audio/wav',
                m4a: 'audio/mp4',
                ogg: 'audio/ogg',
                flac: 'audio/flac'
            }[format.ext] || 'audio/*';
            
            const blob = new Blob([data.buffer], { type: mimeType });
            const url = URL.createObjectURL(blob);
            
            const baseName = file.name.replace(/\.[^/.]+$/, ''); // å»é™¤åŸæ‰©å±•å
            const filename = `${baseName}_converted.${format.ext}`;
            
            return { blob, url, filename };
            
        } finally {
            // æ¸…ç†å†…å­˜
            try {
                await ffmpeg.deleteFile(inputName);
                await ffmpeg.deleteFile(outputName);
            } catch (e) { /* å¿½ç•¥æ¸…ç†é”™è¯¯ */ }
        }
    };

    // æ—§ä»£ç ä¿ç•™ï¼ˆä¸å†ä½¿ç”¨ï¼‰
    const displayFileInfo = async () => {
        const file = uploader.files[0];
        if (!file) return;

        // 1. æ˜¾ç¤ºæ–‡ä»¶å
        document.getElementById('info-name').innerText = file.name;
        infoArea.classList.remove('hidden');

        // 2. è¿è¡Œ ffmpeg -i è·å–å…ƒæ•°æ®
        const inputName = 'input.' + file.name.split('.').pop();
        
        // å†™å…¥æ–‡ä»¶åˆ°å†…å­˜
        await ffmpeg.writeFile(inputName, await fetchFile(file));

        // æ¸…ç©ºæ—¥å¿—åŒºåŸŸï¼Œå‡†å¤‡æ¥æ”¶æ–°çš„å…ƒæ•°æ®
        logEl.innerHTML = `æ­£åœ¨è§£æ ${file.name} çš„å…ƒæ•°æ®...`;
        
        try {
            // è¿è¡Œ -i å‘½ä»¤ï¼ŒFFmpeg ä¼šè¾“å‡ºå…ƒæ•°æ®åˆ° stderr å¹¶æŠ¥é”™ï¼ˆæ­£å¸¸è¡Œä¸ºï¼‰
            await ffmpeg.exec(['-i', inputName]);
        } catch (error) {
            // é¢„æœŸä¼šå¤±è´¥ï¼ˆå› ä¸ºæ²¡æœ‰æŒ‡å®šè¾“å‡ºï¼‰ï¼Œä½†å…ƒæ•°æ®å·²ç»åœ¨æ—¥å¿—ä¸­äº†
        }
        
        // ä»æ—¥å¿—ä¸­æå–æœ€åçš„è¾“å‡ºä¿¡æ¯
        const logs = logEl.innerText;
        const metadata = parseMetadata(logs);

        // æ›´æ–° HTML
        document.getElementById('info-duration').innerText = metadata.duration;
        document.getElementById('info-samplerate').innerText = metadata.sampleRate;
        document.getElementById('info-channels').innerText = metadata.channels;
        document.getElementById('info-bitrate').innerText = metadata.bitrate;
        
        log('å…ƒæ•°æ®è§£æå®Œæˆã€‚');
        
        // æ¸…ç†å†…å­˜ä¸­çš„ä¸´æ—¶æ–‡ä»¶
        try {
            await ffmpeg.deleteFile(inputName);
        } catch (e) { /* å¿½ç•¥æ¸…ç†é”™è¯¯ */ }
    };
    
    // ç»‘å®šæ–‡ä»¶é€‰æ‹©äº‹ä»¶
    uploader.addEventListener('change', displayFileInfo);


    // ------------------------------------
    // 3. å‹ç¼©é€»è¾‘ 
    // ------------------------------------
    const compress = async () => {
        const file = uploader.files[0];
        if (!file) return alert('è¯·å…ˆä¸Šä¼ ä¸€ä¸ª MP3 æ–‡ä»¶');

        btn.disabled = true;
        btn.innerText = 'å‹ç¼©ä¸­...';
        downloadArea.classList.add('hidden');
        
        // æ¸…ç©ºæ—¥å¿—ï¼Œå¼€å§‹æ–°çš„å‹ç¼©ä»»åŠ¡
        logEl.innerHTML = '--- å¼€å§‹å¤„ç† ---';

        try {
            const inputName = 'input.' + file.name.split('.').pop();
            const outputName = 'output.mp3';
            
            // ç¡®ä¿æ–‡ä»¶å·²å†™å…¥å†…å­˜
            await ffmpeg.writeFile(inputName, await fetchFile(file));

            const command = ['-i', inputName];
            
            // --- æå–å¹¶åº”ç”¨æ–°çš„å‚æ•° ---
            
            // è¾“å‡ºå£°é“ (-ac N)
            const ac = outputChannels.value;
            if (ac) {
                command.push('-ac', ac);
                log(`-> è®¾ç½®è¾“å‡ºå£°é“: ${ac}`);
            }

            // é‡‡æ ·ç‡ (-ar HZ)
            const ar = outputSamplerate.value;
            if (ar) {
                command.push('-ar', ar);
                log(`-> è®¾ç½®é‡‡æ ·ç‡: ${ar}`);
            }
            
            // æ¯”ç‰¹ç‡ (-b:a RATE)
            const ba = outputBitrate.value;
            if (ba) {
                command.push('-b:a', ba);
                log(`-> è®¾ç½®æ¯”ç‰¹ç‡: ${ba}`);
            }

            // --- æœ€ç»ˆè¾“å‡º ---
            command.push(outputName);
            
            // æ‰§è¡Œ FFmpeg å‘½ä»¤
            await ffmpeg.exec(command);
            
            // è¯»å–è¾“å‡ºæ–‡ä»¶
            const data = await ffmpeg.readFile(outputName);
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥ (ä¿æŒä¸å˜)
            const blob = new Blob([data.buffer], { type: 'audio/mp3' });
            const url = URL.createObjectURL(blob);
            
            downloadLink.href = url;
            downloadLink.download = `compressed_${ba || 'original'}_${file.name}`;
            
            const originalSize = (file.size / 1024 / 1024).toFixed(2);
            const newSize = (blob.size / 1024 / 1024).toFixed(2);
            document.getElementById('size-info').innerText = `åŸå§‹å¤§å°: ${originalSize} MB -> å‹ç¼©å: ${newSize} MB`;
            
            downloadArea.classList.remove('hidden');
            log('--- å¤„ç†å®Œæˆ ---');
        } catch (error) {
            log(`å¤„ç†å‡ºé”™: ${error.message}`);
        } finally {
            btn.disabled = false;
            btn.innerText = 'å¼€å§‹å‹ç¼©';
            // æ¸…ç†å†…å­˜ä¸­çš„æ–‡ä»¶
            try {
                await ffmpeg.deleteFile(inputName);
                await ffmpeg.deleteFile(outputName);
            } catch (e) { /* å¿½ç•¥æ¸…ç†é”™è¯¯ */ }
        }
    };

    // ç»‘å®šäº‹ä»¶
    uploader.addEventListener('change', displayFileList);
    btn.addEventListener('click', compressBatch);
    
    // å¯åŠ¨åˆå§‹åŒ–
    loadFFmpeg();
</script>

</body>
</html>